# Документация для разработчика: репозиторий `sd_ass_2`

## Обзор

Репозиторий **sd_ass_2** содержит реализацию интеллектуального ассистента для сотрудников и клиентов компании **Интерлизинг**.  Ассистент работает в Telegram, использует библиотеку **aiogram** для обработки событий, **LangGraph** и **LangChain** для построения диалоговых графов, обращается к внутренней базе знаний (KB) компании и внешнему поиску (Yandex) и может выбирать разные LLM‑модели (OpenAI GPT, GigaChat, Gemini, Mistral, Yandex и др.).  Основной скрипт `sd_ass_bot.py` запускает Telegram‑бота, обрабатывающего текстовые, голосовые, фото‑ и документ‑сообщения и передающего их в граф агента для получения ответа.  Пользователь может переключать модель, сбрасывать память, просматривать справку, перезагружать индексы и оценивать ответы.  Бот поддерживает два режима – **polling** или **webhook**, задаваемые переменной окружения `BOT_MODE`.

Ниже описаны архитектура приложения, используемые библиотеки и модели, конфигурационные файлы и переменные окружения.

## Архитектура

### Основные компоненты

| Компонент | Описание |
|---|---|
| **Telegram‑бот (`sd_ass_bot.py`)** | Запускает бота на основе *aiogram* и регистрирует обработчики команд `/start`, `/sber`, `/gpt`, `/reset`, `/help`, `/reload`, `/users` и общих сообщений.  Реализованы: троттлинг запросов на пользователя/чат; выбор модели (GPT, SBER/GigaChat); голосовая транскрипция через Whisper; скачивание изображений и генерация описаний; передача сообщения в агент и потоковая отправка ответа; сохранение оценок ответов в Google Sheets; периодическое обновление индексов базы знаний с возможностью приостановки и возобновления【239990003648423†L27-L51】. |
| **Граф агента (`agents/agent.py`)** | Построен с использованием **LangGraph**: содержит вершины для получения информации о пользователе, сброса памяти, обогащения запроса глоссарными терминами и маршрутизации запроса.  Вершины асинхронно вызывают соответствующих агентов (`sd_agent`, `sm_agent`, `default_agent`) в зависимости от классификации запроса, и узел проверки ответа.  Память ведётся с помощью `MemorySaver`; при включении анонимизации используется библиотека *Palimpsest* для замены персональных данных【925512324869568†L90-L99】. |
| **Агенты ролей (service desk/sales/default)** | Для каждой роли существует отдельный «агент» на основе **React Agent** LangGraph.  Каждый агент использует *LLM* (выбирается на основе провайдера и режима: `base`, `mini` или `nano`) и набор инструментов: поиск в базе знаний (`search_kb`), поиск по тикетам (`search_tickets` для service desk), поиск терминов и сокращений (`lookup_term`, `lookup_abbreviation`) и внешнюю поисковую систему Yandex (`yandex_web_search`).  Для каждого агента заданы системные подсказки (файлы в каталоге `prompts`) и шаблон ответа. |
| **Классификатор запросов (`agents/classifier.py`)** | Использует API Яндекс Cloud Few‑Shot Text Classification для отнесения текста пользователя к одной из категорий: *sales and products*, *human resources*, *technical support*.  Эта метка используется функцией `route_request` для выбора роли агента【154272452514226†L10-L30】. |
| **Подсистема поиска и индексов (`agents/retrievers`)** | Включает обёртки для API Teamly (knowledge base, тикеты, глоссарий) и сборку индексов FAISS/BM25.  Система реализует гибридные поисковики – семантический (на основе **HuggingFace embeddings**), BM25 и гибридный рекомбинатор.  Для улучшения результатов применяется переранжирование с помощью кросс‑энкодера (`CrossEncoderRerankerWithScore`) и ранжирование через LLM (`RankLLMRerank_GV`)【131925160162860†L17-L44】. |
| **Дополнительные утилиты** | Файл `bot_helpers.py` содержит функции для отображения действий в Telegram (типа «печатает»), отправки потокового текста, правильной разбивки больших сообщений и др.【590107314975852†L39-L47】; `user_manager/utils.py` управляет правами пользователей и загрузкой списка допустимых моделей из Google Sheets; `utils/periodic_task.py` реализует периодическую задачу для обновления индексов базы знаний; `utils/llm_logger.py` ведёт логирование запросов и ответов LLM в JSON. |

### Поток обработки запроса

1. **Приём сообщения**.  Telegram‑бот (`sd_ass_bot.py`) получает сообщение и выбирает соответствующую модель и настройки потока (`ThreadSettings`), создавая экземпляр агента.  Для голосовых сообщений выполняется распознавание через **Whisper**; для изображений – скачивание, преобразование в base64 и вызов `summarise_image` для генерации ключевых слов.
2. **Создание состояния**.  Передача запроса в `langgraph` создаёт состояние `State` с полями `messages`, `user_info`, `last_question` и др.  Утилита `State` также содержит функцию `add_messages_no_img` для удаления ссылок на изображения из истории сообщений【822161146376056†L6-L15】.
3. **Узлы графа**:
   * `fetch_user_info` – извлекает ID и роль пользователя, используя класс `UserManager`【630538632947832†L5-L11】.
   * `reset_memory` – очищает историю сообщений, если пользователь отправил тип `reset`.  Узел возвращает список `RemoveMessage` для удаления всех сообщений из памяти【925512324869568†L52-L55】.
   * `augment_query` – дополняет входной запрос определениями из глоссария.  Файл `agents/augment_query.py` загружает все термины из API Teamly, использует **pymorphy2** для морфологической нормализации и fuzzy‑matching для поиска релевантных терминов и возвращает сокращённый список определений【577616381120544†L20-L41】.
   * `route_request` – агрегирует текст всех пользовательских сообщений, суммирует его с указанием роли и вызывает классификатор `classify_request` для определения категории запроса.  В зависимости от метки граф передаёт управление в один из трёх агентов: `sm_agent` (sales), `sd_agent` (service desk) или `default_agent`【925512324869568†L43-L50】.
4. **Вызов агента**.  Каждый агент создаётся функцией `assistant_factory` в `agents/assistants/assistant.py`.  Она подбирает модель (OpenAI GPT, GigaChat, Mistral, Gemini, Yandex GPT или локальную), связывает инструменты с моделью и формирует шаблон запроса.  Для локальных моделей используется класс `ChatLocalTools`, который обнаруживает вызовы инструментов в выводе модели и исполняет их рекурсивно【401622478593746†L76-L100】.  Для моделей Яндекса используется `ChatYandexGPTWithTools`, реализующий двухфазный протокол: сперва модель возвращает список вызовов инструментов, затем после исполнения инструментов отправляется второй запрос с их результатами【908903125758126†L24-L70】.
5. **Валидация ответа и внешние поиски**.  После получения ответа от агента вызывается `validate_answer`, который использует дополнительную LLM (см. `VALIDATION_LLM`) и prompt из `prompts/check_answer_prompt.txt` для проверки корректности ответа.  Если модель считает ответ неполным или неверным, вызывается вспомогательный агент `web_search_agent`, использующий **Yandex** для поиска в интернете и формирующий новую версию ответа【925512324869568†L122-L131】.  Таким образом, бот уменьшает галлюцинации и исправляет ответы при помощи внешнего поиска.
6. **Потоковая отправка**.  `bot_helpers.collect_final_text_from_stream` собирает потоковые ответы от `assistant.stream` и отправляет их пользователю, имитируя плавную печать.  Сообщение разбивается на куски длиной ~3800 символов, форматируется с помощью `telegramify_markdown`, а при ошибке форматирования отправляется как обычный текст【590107314975852†L38-L49】.

На рисунке ниже изображена упрощённая визуализация графа `langgraph`, показывающая основные узлы (`__start__`, `fetch_user_info`, `reset_memory`, `assistant`, `tools`) и их связи:

![Упрощённая визуализация графа]({{file:file-BaqMYayNRNpGxkbfwD19wT}})

## Внешние зависимости

Файл `requirements.txt` содержит множество зависимостей.  Ключевые библиотеки и их назначение:

| Библиотека | Назначение |
|---|---|
| **aiogram** | Работа с Telegram Bot API, обработка сообщений и команд. |
| **langgraph**, **langgraph_supervisor** | Создание и исполнение диалоговых графов для управления состоянием и инструментами. |
| **langchain**, **langchain_core**, **langchain_community**, **langchain_huggingface**, **langchain_openai**, **langchain_mistralai**, **langchain_gigachat** | Интеграция с различными LLM‑провайдерами и инструментами поиска; создание цепочек запросов. |
| **transformers**, **torch**, **sentencepiece**, **accelerate** | Работа с моделями HuggingFace: локальный LLM, эмбеддинги, кросс‑энкодер. |
| **faiss-cpu**, **rank_bm25** | Семантический и классический полнотекстовый поиск. |
| **pymorphy2**, **fuzzywuzzy** | Морфологический анализ и нечёткое сравнение для поиска терминов и сокращений. |
| **pymupdf (fitz)**, **Pillow**, **trafilatura** | Извлечение текста и изображений из PDF, обработка изображений и извлечение содержимого веб‑страниц. |
| **openai-whisper** | Модель Whisper для распознавания речи, используемая в `vrecog/vrecog.py` для преобразования аудио в текст【307298715467416†L10-L13】. |
| **palimpsest** | Анонимизация текстов: удаление персональных данных (ФИО, номера паспорта, IP‑адреса и др.) перед передачей в LLM. |
| **google-api-python-client**, **google-auth-httplib2**, **pandas** | Доступ к Google Sheets для загрузки списка пользователей, сохранения оценок и работы с таблицами в `store_managers/google_sheets_man.py`【310385148201115†L20-L49】. |
| **yandexcloud**, **duckduckgo-search** | Обращение к API Yandex для поиска и классификации, а также запасной поиск DuckDuckGo. |
| **langfuse** | Интеграция с платформой Langfuse для мониторинга и трассировки запросов. |

Дополнительно в `requirements.txt` присутствуют библиотеки `spacy` и `scispacy` для возможного расширения NLP‑функций, `grpcio` для взаимодействия с некоторыми облачными сервисами, `telegramify-markdown` для безопасного преобразования Markdown, и другие утилиты.

## Модели и провайдеры

Файл `models.toml` определяет соответствие между режимами (base/mini/nano) и конкретными LLM‑названиями для каждого провайдера.  Например, для **OpenAI** задано: `base = gpt‑4.1`, `mini = gpt‑4.1‑mini`, `nano = gpt‑4.1‑nano`; для **GigaChat** – `base = GigaChat‑2‑Pro`, `mini = GigaChat‑2`, `nano = GigaChat‑2`【957526072564423†L2-L8】.  Выбор модели задаётся переменными `TEAM_GPT_MODEL` и `LLM_PROVIDER` в `config.py`.  Поддерживаются провайдеры: OpenAI, Anthropic (Claude), Gemini, GigaChat (Сбер), Mistral, Yandex.

**Эмбеддинги и переранжировка.**  Переменная `EMBEDDING_MODEL` указывает путь или имя модели эмбеддингов HuggingFace (по умолчанию `/models/multilingual-e5-large`【9696521785975†L15-L16】).  Переменная `RERANKING_MODEL` задаёт модель кросс‑энкодера для переранжировки (по умолчанию `/models/bge-reranker-large`【9696521785975†L46-L47】).  В файле `agents/retrievers/utils/models_builder.py` реализована функция, которая загружает эти модели в соответствии с конфигурацией.

**Whisper.**  Пара `WHISPER_MODEL` и `WHISPER_MODEL_PATH` определяют, какую модель Whisper использовать для голосовой транскрипции.  По умолчанию используется модель `small`【9696521785975†L36-L38】.

## Конфигурационные файлы

### `config.py`

Файл `config.py` загружает значения из файла `gv.env` (если существует в рабочей директории или в `$HOME/.env`) с помощью `python-dotenv` и задаёт переменные для всего приложения.  Основные параметры:

| Переменная | Назначение и значение по умолчанию |
|---|---|
| **IL_PWD / PASSWORD** | Пароль для входа на портал knowledge base (используется для Chrome/Teamly).  По умолчанию `"NOTINUSE"`【9696521785975†L8-L11】. |
| **LOCAL_MODEL_NAME** | Путь к локальной LLM (Q8 версия модели Llama‑3 8B) для режима `local`【9696521785975†L10-L11】. |
| **TELEGRAM_ASSISTANT_BOT_TOKEN** | Токен Telegram‑бота. |
| **EMBEDDING_MODEL** | Модель эмбеддингов.  По умолчанию `/models/multilingual-e5-large`【9696521785975†L15-L16】. |
| **GIGA_CHAT_USER_ID, GIGA_CHAT_SECRET, GIGA_CHAT_AUTH** | Учётные данные для доступа к API GigaChat (Сбер)【9696521785975†L17-L19】. |
| **LANGCHAIN_API_KEY** | API‑ключ для LangChain (необязательно). |
| **OPENAI_API_KEY / YA_API_KEY / YA_FOLDER_ID / YA_AUTH_TOKEN / GEMINI_API_KEY** | Ключи для соответствующих LLM‑провайдеров (OpenAI, Yandex, Gemini). |
| **CHECK_RIGHTS** | При значении `True` включает проверку прав пользователя; используется в `user_manager`【9696521785975†L32-L34】. |
| **USERS_SHEET_ID / FEEDBACK_SHEET_ID / GOOGLE_SHEETS_CRED** | Идентификаторы Google Sheets с данными о пользователях и листом для отзывов и файл с сервисным аккаунтом【9696521785975†L32-L35】. |
| **JINA_API_KEY** | Ключ для генерации эмбеддингов Jina AI (необязательно). |
| **WHISPER_MODEL / WHISPER_MODEL_PATH** | Настройки для Whisper (модель и путь). |
| **UPD_TIMEOUT** | Интервал (в секундах) между обновлениями индексов базы знаний; по умолчанию 300 секунд【9696521785975†L38-L39】. |
| **NOTION_INDEX_FOLDER / CHATS_INDEX_FOLDER / ASSISTANT_INDEX_FOLDER** | Пути к директориям индексов для базы знаний, чатов и ассистента【9696521785975†L42-L46】. |
| **RERANKING_MODEL** | Модель кросс‑энкодера для переранжировки (по умолчанию `/models/bge-reranker-large`)【9696521785975†L46-L47】. |
| **NO_CUDA** | Если `True`, скрывает GPU (используется в `sd_ass_bot.py`)【9696521785975†L47-L48】. |
| **DEBUG_WORKFLOW** | Включает отладочный режим LangGraph. |
| **RETRIEVER_TYPE** | Выбор типа поисковой подсистемы (`teamly` или `faiss`)【9696521785975†L49-L50】. |
| **TEAM_GPT_MODEL** | Режим LLM для агента (`nano`, `mini` или `base`); по умолчанию `nano`【9696521785975†L50-L51】. |
| **LLM_PROVIDER** | Провайдер LLM (OpenAI, GigaChat, Gemini, Mistral, Yandex). |
| **VALIDATION_LLM** | Провайдер для валидации ответа (например, `openai`). |
| **BOT_MODE** | Режим работы бота – `polling` или `webhook`【9696521785975†L52-L53】. |
| **WEBHOOK_* (WEBHOOK_BASE, WEBAPP_HOST, WEBAPP_PORT, WEBHOOK_PATH, WEBHOOK_SECRET)** | Параметры для настройки webhook‑режима【9696521785975†L54-L58】. |
| **MIN_RERANKER_RATIO** | Минимальная доля документов, прошедших переранжировку (значение по умолчанию `0.25`)【9696521785975†L59-L60】. |
| **MAX_TEAMLY_DOCS** | Максимальное количество документов, извлекаемых из базы знаний (по умолчанию 20)【9696521785975†L60-L61】. |
| **LANGFUSE_SECRET / LANGFUSE_PUBLIC / LANGFUSE_URL** | Ключи и URL для интеграции с Langfuse【9696521785975†L61-L63】. |

Дополнительно файл `langgraph.json` описывает расположение графа (`assistant_agent` → `call_agent.py:agent`), версию Python (3.12) и файл `.env` для переменных【987456745646052†L2-L3】.

### Файлы `prompts`

Каталог `prompts` содержит набор подробных системных подсказок.  Основные:

* **working_prompt.txt** – инструкция для Service‑Desk агента: всегда отвечать на русском, использовать инструменты в строгом порядке (`lookup_term`, `lookup_abbreviation`, `search_kb`, `search_tickets`), не галлюцинировать, не отвечать до получения результатов `search_kb`, следовать шаблону ответа (рекомендуемое решение, аналогичные тикеты, релевантные статьи и т.д.)【933802260781461†L32-L52】.
* **working_prompt_sales.txt** – аналогичная инструкция для отдела продаж; предписывает использовать `search_kb` и избегать внешних ссылок; тема поиска – продажи и продукты Интерлизинга【675095961101857†L18-L30】.
* **working_prompt_employee.txt** – инструкция для обычных сотрудников; стиль более дружелюбный, допускаются шутки; основным инструментом является `search_kb`, а `search_tickets` отсутствует【173044981495283†L20-L32】.
* **search_web_prompt.txt**, **search_web_prompt_sales.txt**, **search_web_prompt_employee.txt** – инструкции для агентов, выполняющих внешний поиск Яндекс; требуют обязательного вызова `yandex_web_search`, запрет на отправку сообщений до завершения поиска и указание формата ответа【599921304848944†L18-L26】.
* **supervisor_prompt.txt** – подсказка для «супервайзера», управляющего несколькими агентами; требует разбиения запроса на подзадачи и агрегации информации от агентов; он не должен раскрывать пользователю, что данные получены от других агентов【909349572176461†L10-L21】.

## Работа с базой знаний и поисковыми инструментами

### Knowledge Base (Teamly)

В каталоге `agents/retrievers/teamly_api_wrapper.py` реализован доступ к внутреннему порталу Interleasing **Teamly**.  Класс `TeamlyAPIWrapper` управляет авторизацией, автоматически обновляет токен и преобразует JSON‑структуру ProseMirror в обычный текст; существуют отдельные классы для статей базы знаний, тикетов и глоссария.  Для каждой сущности производится создание объектов **LangChain Document**.  Обёртка умеет сохранять скачанные данные в файлы и обновлять их периодически.  Функция `GLOSSARY_ARTICLE_IDS` определяет набор ID статей глоссария для загрузки.  В модуле `agents/retrievers/teamly_retriever.py` представлены гибридные ретриверы (`HybridTeamlyRetriever`), соединяющие семантический поиск (FAISS), BM25 и удалённые результаты Teamly; они используют `CrossEncoderRerankerWithScore` для переранжировки и могут обновлять индексы через метод `refresh`.

### Инструменты

* **search_kb** – ищет статьи в базе знаний через выбранный ретривер (Teamly или FAISS).  Возвращает список документов с названиями, ссылками и содержанием.
* **search_tickets** – аналогично, но для базы тикетов; используется только в service‑desk режиме.
* **lookup_term** и **lookup_abbreviation** – получают определения терминов и сокращений из глоссария Teamly; применяют морфологический анализ и fuzzy‑matching для лучшего совпадения【577616381120544†L42-L87】.
* **yandex_web_search** (файл `agents/tools/yandex_search.py`) – обращается к `searchapi.api.cloud.yandex.net` и загружает первые результаты, декодирует base64‑контент, очищает HTML с помощью *trafilatura* и возвращает обобщённый текст с ссылками【390476316551989†L13-L33】.
* **validate_answer** – валидирует ответы агента, используя отдельную LLM и подсказку из `prompts/check_answer_prompt.txt`.  При неудовлетворительном ответе инициирует web‑поиск и формирует новую версию ответа【925512324869568†L122-L131】.

## Взаимодействие с пользователями

* **/start** – создаёт новый `ThreadSettings`, сбрасывает память агента и приветствует пользователя, отправляя запрос «Представься и расскажи о себе».  Ответ передаётся потоково【239990003648423†L62-L70】.
* **/sber** и **/gpt** – переключают модель на GigaChat или GPT соответственно, обновляя `ThreadSettings.model` и пересоздавая агента【239990003648423†L75-L82】.
* **/reset** – очищает память агента (не меняет историю чата)【239990003648423†L83-L89】.
* **/help** – выводит файл `help/help.md`, описывающий назначение ассистента, доступные команды и режимы работы.
* **/reload** – обновляет индексы базы знаний, вызывая `refresh_indexes` из `agents.retrievers.utils.load_common_retrievers`.
* **/users** – администраторская команда для загрузки списка пользователей и просмотра их прав (получает данные из Google Sheet).

При получении текстового/голосового/фото сообщения бот отправляет действие «typing» или «upload_photo/voice», формирует сообщение в формате `HumanMessage` и передаёт его в `assistant.stream`.  Итоговый ответ отправляется после завершения генерации, затем пользователю предлагается оценить ответ через inline‑клавиатуру (`/rate_1`, `/rate_2`, `/rate_3`).  Оценки записываются в Google Sheet через `store_managers/google_sheets_man.py`.

## Заключение

Репозиторий **sd_ass_2** представляет собой сложную интеграцию Telegram‑бота, модульных агентов на основе LangGraph/LangChain, гибридного поиска по внутренней базе знаний и внешнему интернету, а также системы оценки качества ответов.  Гибкость обеспечивается сменой провайдеров LLM и детальной конфигурацией через файл `config.py` и переменные окружения.  Разработчику, желающему расширить функциональность, следует обратить внимание на следующие места:

* **Новые инструменты** можно добавлять в `agents/tools` и регистрировать их в `assistant_factory`.
* **Модели** – для добавления поддерживаемого провайдера нужно расширить `models.toml`, `agents/llm_utils.py` и предусмотреть загрузку ключей в `config.py`.
* **Промпты** – системные подсказки лежат в каталоге `prompts`; изменение поведения агентов осуществляется редактированием соответствующих файлов.
* **Retrieval** – для подключения новой БД необходимо реализовать обёртку в `agents/retrievers`, добавить нужные индексы в `utils/load_common_retrievers.py` и зарегистрировать инструмент в `agents/retrievers/retriever.py`.

Данный документ описывает структуру приложения и может служить отправной точкой для разработки и эксплуатации ассистента.